--- 
title: PHP, DTOs and You 🫵
categories: [programming,php]
date: 2024-12-28
toc: true
draft: true
---

In my previous post I talked about [Value
Objects]({{< ref "11-24-php-value-objects-and-you" >}}) in this post I will
talk about DTOs - **Data Transfer Objects**.

Identifying a DTO
-----------------

The following statements are always true:

- DTOs are intended to be **serialized** and/or **deserialized**.
- DTOs do not have **business** logic.

And I would consider the following statements to be **virtuous**:

- DTOs are read-only and final.
- DTOs only have public properties.
- DTOs have no getters or setters.
- DTOs contain only primitive types or other DTOs.
- DTOs are **not** responsible for their own serialization and
  deserialization.
- DTOs do not penetrate beyond the frontiers of your application.
- DTOs are exact representations of the incoming or outgoing data.

What is a DTO?
--------------

Data Transfer Objects (DTOs) are used to give structure to the input
and output of your application and incidentally enable you to decouple the
input and output from your business model.

DTOs can be created **from** and/or converted **to** an unstructured
representation, typically an `array` in PHP.

Below we have a DTO representing an sporting activity from the
world renowned Sportster internet application:

```php
class SportsterActivityDTO {
    public function __construct(
        public string $title,
        public string $date,
        public float $distance,
        public float $time
        public ?float $averageHeartRate
    ) {}
}
```

We get the following data from the Sportser API:

```php
$array = [
    'title' => 'Run along the Esplanade',
    'date' => '2018-02-20T18:02:13Z',
    'distance' => 10000,
    'time' => 2700,
]
```

We then use a mapper library to _map_ this array data to the DTO:

```php
$dto = Mapper::create()->fromArray(SportsterActivityDTO::class, $array);
var_dump($dto->title); // prints "Run along the Esplanade"
```

We can also map the DTO _back_ to an array:

```php
$newArray = $mapper->toArray($dto);
var_dump($newArray == $array); // prints "true". we converted the DTO back to the original form.
```

{{< callout >}}
You may also see `toArray` and `fromArray` methods on DTOs themselves in the
wild, or maybe even `toJson` and `fromJson`. I think this is **BAD**
and we'll find out why later!
{{< / callout >}}

Example Sportster API
---------------------

Let's use the famous Sportster Developer API to fetch an activity badly and persist it to our database:

```php
// badly fetch the JSON data from the API and decode it to a PHP array
$activity = json_decode(file_get_contents('https://sporster.example.com/activity/11'), true);

// badly insert the activity into the database
$database->exec('INSERT INTO activity (
    id,
    title,
    date,
    distance,
    time,
    averageHeartRate
) VALUES (?, ?, ?, ?, ?, ?)', [
    $activity['id'],
    $activity['title'],
    $activity['date'],
    $activity['distance'],
    $activity['time'],
]);
```

Focus on the bad `$activity` - the code has no way of knowing if:

- if `$activity` is an array.
- if `$activity` has all the required keys.
- if the types in `$activity` are the expected types.

What's worse is that **YOU** have no way of knowing what's in the bad
`$activity`! We _think_ it _should_ have the keys we're accessing but there
are no guarantees. Let's add some assertions:

```php
// fetch the JSON data from the API and decode it to a PHP array
$activity = json_decode(file_get_contents('https://sporster.example.com/activity/11'), true);

if (!is_array($activity)) {
    throw new Exception('Expected an array!');
}

$requiredFields = ['id', 'title', 'date', 'distance', 'time'];
$missingFields = array_diff($requiredFields, array_keys($activity));
if ($missingFields) {
    throw new Exception(sprintf('Activity is missing fields: %s', implode(', ', $missingFields)));
}

if (!is_string($activity['id'])) {
    throw new Exception(sprintf('ID must be a string, got: %s', get_debug_type($activity['id'])));
}

if (!is_string($activity['title'])) {
    throw new Exception(sprintf('Title must be a string, got: %s', get_debug_type($activity['title'])));
}

// check all the other types
// ...

// insert the activity into the database
$database->exec('INSERT INTO activity (
    id,
    title,
    date,
    distance,
    time,
    averageHeartRate
) VALUES (?, ?, ?, ?, ?, ?)', [
    $activity['id'],
    $activity['title'],
    $activity['date'],
    $activity['distance'],
    $activity['time'],
]);
```

Not quite so bad. By the time we get to inserting our data into the database **we
are safe**. But that was lots of work! We've written lots of **boilerplate**.
Writing boilerplate doesn't scale:

- Boilerplate is **time consuming**.
- Boilerplate is a **breeding ground for bugs** 🐛.
- Boilerplate is a **code smell** 💩 and don't let anybody gaslight you into a
  different opinion.

And if we want to use our `$activity` somewhere else:

```php
function analyse_activity(array $activity): ActivityAnalysis
{
    // ...
}
```

We would need to validate `$activity` all over again! But Dan! for fuck's
sake **use a class already**!

You're right - **damn you**. Let's go back and use a DTO and a serializer:

```php
// fetch the JSON data from the API and decode it to a PHP array
$data = file_get_contents('https://sporster.example.com/activity/11');

// use a serializer to decode the JSON and map the data to a DTO class
$activityDTO = $jsonSerializer->deserialize(SportsterActivityDTO::class, $data);

// insert the activity into the database
$database->exec('INSERT INTO activity (
    id,
    title,
    date,
    distance,
    time,
    averageHeartRate
) VALUES (?, ?, ?, ?, ?, ?)', [
    $activityDTO->id,
    $activityDTO->title,
    $activityDTO->date,
    $activityDTO->distance,
    $activityDTO->time,
]);
```

**Oh boy** that's less code! It's almost the same amount of code as when we
did no validation at all!

- We have a strongly typed object - the DTO.
- The serializer should fail **usefully**.
- The properties of the DTO are available statically.

This is better code, especially in the context of this example, but in a real
application we would probably not want the DTO to penetrate to the persistence
layer.

{{< callout >}}
I've been using the term "serializer". The simple fact is that you _need_ one
to work with DTOs in the way I am presenting in this article.
Unfotunately there is no perfect solution in PHP, here are some representative
libraries:

- [Symfony Serializer](https://symfony.com/doc/current/serializer.html): It
  _mostly_ works. Quite fast, doesn't support generics, doesn't throw _structured_ errors.
- [Valinor](https://valinor.cuyz.io/latest/): Bit slow, supports generics and
  orther advanced types, throws structured
  errors.
- [Object Mapper](https://github.com/thephpleague/object-mapper): Fastest (generates code), no generics, worst error messages.

There are also some newer libraries such as [Serde](https://github.com/Crell/Serde) which I have not tried out.
{{< /callout >}}

## Mapping to Entities

In our application we have an `Activity` _entity_ that's managed by an ORM:

```php
$activityEntity = new Activity(12, 'Park Run', new DateTimeImmutable('2024-01-01'), 5000, 1260);
$orm->save($activityEntity);
```

That's sure better than writing all that SQL and we have an rich domain object - an **entity** - where we can use value objects:

```php
$activity->title() // "Park Run"
$activity->distance()->asMiles(); // 3.1
$activity->time()->asStopwatch(); // "21:04"
```

I know what you're thinking! **LET'S MAP TO THE ENTITY INSTEAD OF THE DTO**:

```php
// no no no no no no no
$entity = $jsonSerizliser->deserialize(ActivityEntity::class, $json);
```

**SHUT YOUR UGLY FACE**. We do not want our domain object to be coupled to the Sportster API. This will not scale:

- Sportster **changes penetrate into the core of our application**. That's bad!
- We inherit any idiosyncrasies of **their** API in **our** model.
- It makes adding non-Sportster integrations exponentially harder.

Our **entity** should be modelled to **our** application. **Leave to Sportster what
is Sportster's**. This is about **ownership**. **This DTO** is not ours even though we created it.

Instead we map the DTO to the entity:

```php
$sportsterDTO = $jsonSerializer->deserialize(SportsterActivityDTO::class, file_get_contents('https://sportster.example.com/activity/1'));

$activity1 = new Activity(
     $sportsterDTO->title,
     new DateTimeImmutable($sportster->date),
     $sportsterDTO->distance,
     $sportsterDTO->time,
);
$orm->save($activity1);

// Runner is another imaginary sports tracking platform
$runnerDTO = $jsonSerializer->deserialize(RunnerDTO::class, file_get_contents('https://runner.example.com/activities/1234-1234'));
$activity2 = new Activity(
     $runnerDTO->title,
     new DateTimeImmutable($runnerDTO->date),
     $runnerDTO->distance,
     $runnerDTO->time,
);
$orm->save($activity2);
```

## DTO Mapping

I like to shift the DTO => Entity mapping to the DTO itself:


```php
$sportsterDTO = $jsonSerializer->deserialize(SportsterActivityDTO::class, file_get_contents('https://sportster.example.com/activity/1'));

$activity1 = $sportsterDTO->toActivity();
$orm->save($activity1);

$runnerDTO = $jsonSerializer->deserialize(RunnerDTO::class, file_get_contents('https://runner.example.com/activities/1234-1234'));
$activity2 = $runnerDTO->toActivity();
$orm->save($activity2);
```

This approach **couples the DTO to the Entity** which I think is **fine** because
the DTO is not our core domain. If we were to do the opposite and couple the
Entity to the DTO that would be (rather) **WORSE** as the entity would have knowlege about
all our integrations.

This pattern also works the other way around:

```php
$dto = RunnerDTO::fromActvity($activity);
```

## Web APIs

Until now we are using DTOs to represent a payload from a vendor's web API,
you'd commonly also use this pattern in your own web API:

```php
class ActivityController
{
    // ...
    public function get(string $activityId): Response
    {
        $activity = $this->repository->get($activityId);
        if (!$activity) {
            throw new HttpNotFoundException(sprintf(
                'Activity %s not found', $activityId
            ));
        }
        $dto = ActivityDTO::fromActivity($activity);

        return new Response(200, $this->jsonSerializer->serialize($dto));
    }
}
```

In this case it's good to think of the DTO as being **owned by the end-user** of
your API. You _could_ change the DTO's structure, but you'd make your users
very unhappy indeed. The DTO provides a **stable representation** of your
data while the underlying **model** can change. Your users like stability. **Be
nice to them**.

## Validation

You ~~may~~ should want to **protect** your **entity** from dirty third-party libraries such as
validators. Your core business model should not be concerned about the user
interface, and validation messages are made _for the user interface_ whether
that be a HTML or JSON response.

DTOs are the place to add validation rules:

```php
use Validator\Constraints;

final readonly class NewActivityDTO {
    public function __construct(
        #[Constraints\NotEmpty()]
        public string $title;

        #[Constraints\GreaterThan(0, message: 'Distance must be greater than 0')]
        public int $distance;

        // ...
    ) {}
}
```

DTOs both map directly to the data being submitted by the user and sit
_outside_ of your core domain. Go crazy with attributes!

{{< callout >}}
But Dan - I read the DDD book and it says that my entities and value objects should
_also_ be responsible for ensuring that they have valid state. Does this mean
I need to apply the **same rules in two places?**

Having the same validation in two or more places is a problem for sure (hi
Javascript password validation! 👋) but the assertions used in entities and
value objects are different from validation rules targetted at the user's interface.

Value Objects and Entities _guard_ their state. It's impossible to have a
negative `Distance` for example, so a `Distance` value object should throw an
exception when that is the case. But `Distance::fromMeters(1)` is a valid
distance - however if you're recording a bicycle ride, then maybe you forgot
to add some zeros and the user interface could tell you to correct your
mistake.

Sometimes you will duplicate validation rules between the user interface and
the domain. Sometimes you may want to _use_ the domain to inform the user
validation but the _domain_ shouldn't be aware of the user interface.
{{</ callout >}}

## No `fromArray`, no `toArray`

One common pattern is `toArray` and `fromArray`:

```php
$dto = StravaActivity::fromArray(json_decode($payload, true));
```

or even:

```php
$dto = SportsterActivityDTO::fromJson($payload);
```

That's **neat** right? What's wrong with it, Dan?

```php
class SportsterActivityDTO {
    // ...
    public static function fromArray(array $array)
    {
        if (!isset($array['id'])) {
            throw new Exception('Invalid data');
        }
        if (!isset($array['title'])) {
            throw new Exception('time is missing');
        }
        if (!isset($array['distance'])) {
            throw new Exception('time is missing');
        }
        return new self($array['id'], $array['title'], $array['dstance'], //
        ...);
    }
    // ...
}
```

That's wrong. In the above code we have at least the following problems:

- The first error message is too general.
- The second error should be `distance is missing` and not `time is missing`.
- The third error is the same as the second.
- We access `dstance` instead of the checked `distance` key.
- This ~~boilerplate~~ technical-debt scales up linearly by the number of DTOs.

In short, this shit code is **RIPE** for bugs and misleading errors. It's also
something that can be **totally automated** because the DTO class definition
provides **all the information that is required**:

```php
class SportsterActivityDTO {
    public function __construct(
        public string $title,
        public string $date,
        public float $distance,
        public float $time
        public ?float $averageHeartRate
    ) {}
}
```

A mapping or serializer library can look at this class and infer the data structure:

```text
title: string
date: string
distance: float
time: int
average_heart_rate: float, optional
```

By using that schema we can map to our DTO:

- **constistently**: error messages will all have the same format, field names
  map exactly to property names.
- **accurately**: error messages will not have typos or ommit field names.
- **configurably**: you have one place to decide which [case](https://en.wikipedia.org/wiki/Camel_case) to use.

In short **mapping from unknown sources** is a hard problem. You shouldn't
try to solve it. Provide a _schema_ in the form of the DTO and let a library
do it for you.

{{< callout >}}
One exception here might be if you generate your DTOs, if you generate your
DTOs then having `fromArray` and `toArray` is more acceptable as the
serialization logic is contained in the code generator, just make
sure the generaterd code is not committed to your git repository and that you
are not [Beezlebub](https://en.wikipedia.org/wiki/Beelzebub).
{{< /callout >}}

## No Entity Serialization

One pattern that was early some years ago was mapping requests directly to
entities instead of using an intermediate DTO:

```php
$activity = $jsonSerializer->deserialize(ActivityEntity::class, $array);
```

This is **bad** because our internal `ActivityEntity` representation is coupled to the external representation. Worse - it could be coupled to multiple representations:

```php
// using attributes to add metadata to tell a serializer how to map
// different representations to and from the entity.
class ActivityEntity
{
    private int $id;
    #[SerializedName('id', group: 'Sportster')]
    private int $externalId;
    public function __construct(
        #[SerializedName('title', group: 'Sportster')]
        #[SerializedName('name', group: 'Runner')]
        private string $title,
        #[SerializedName('distance', group: ['Sportster', 'Runner'])]
        private int $distance,
        // ...
    ) {}
}
```

This is fine right?! No! You like it? I don't. **But wait**: we want to use a
`Distance` Value Object:

```php
class ActivityEntity
{
    // ...
    public function __construct(
        // ...
        #[SerializedName('distance', group: ['Sportster', 'Runner'])]
        private Distance $distance,
        // ...
    ) {}
}
```

Oh no, more complexity! We'll have to tell the serializer how to serialize
`Distance`.

{{< callout >}}
The more likely outcome is that the developer will **NOT** use a value object
here **because** of the difficulty of serialization. This is a great example
of third-party libraries falsely informing our domain design.
{{< /callout >}}

It's better to create a simple DTO for each representation and map the DTO explicitly to the entity.

```php
new Activity(
    externalId: $runnerDTO->id,
    title: $runnerDTO->name,
    distance: Distance::fromMeters($runnerDTO->distance),
    // ...
);
```

The hardest part isn't the above code. The above code is _safe_ and
_maintainable_, the hardest
part is converting unsafe data to a safe object, the result of that is the
DTO.

{{< callout >}}
I won't say anything about mapping value objects in ORMs 🤐 But yes.
{{< /callout >}}

## No Packages or Abstract Classes

The DTO defines a data structure, in general it should not extend another
class or implement an interface.

```php
// don't do this
final readonly class SportsterRouteDTO extends DTO {
```

DTOs can be defined entirely via. it's constructor:

```php
final readonly class SportsterRouteDTO {
    public function __construct(
        public string $title,
        /** @var list<array{float,float}> */
        public array $coords,
        public string $createdAt,
    ) {}
}
```

They have no behavior, just structured data.

## No Value Objects

## No Property Mapping
